# coding: utf-8

"""
    Respeecher API

    API for interacting with Respeecher services, including key and session management, and calibration functionalities.  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from respeecher.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_calibration(self, name, data, **kwargs):  # noqa: E501
        """Create a new Calibration  # noqa: E501

        Currently the supported audio formats are wav, ogg, mp3 or flac.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_calibration(name, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: (required)
        :param str data: (required)
        :return: CalibrationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_calibration_with_http_info(name, data, **kwargs)  # noqa: E501
        else:
            (data) = self.create_calibration_with_http_info(name, data, **kwargs)  # noqa: E501
            return data

    def create_calibration_with_http_info(self, name, data, **kwargs):  # noqa: E501
        """Create a new Calibration  # noqa: E501

        Currently the supported audio formats are wav, ogg, mp3 or flac.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_calibration_with_http_info(name, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: (required)
        :param str data: (required)
        :return: CalibrationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_calibration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_calibration`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `create_calibration`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'data' in params:
            local_var_files['data'] = params['data']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/calibration', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CalibrationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_folder(self, body, **kwargs):  # noqa: E501
        """Create a folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderRequest body: (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_folder_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_folder_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_folder_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderRequest body: (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/folders', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Folder',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_note(self, body, **kwargs):  # noqa: E501
        """Create a note associated with a recording  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_note(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NoteRequest body: (required)
        :return: NoteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_note_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_note_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_note_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a note associated with a recording  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_note_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NoteRequest body: (required)
        :return: NoteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/notes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NoteResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_order(self, body, **kwargs):  # noqa: E501
        """Create a conversion order  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_order(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OrderRequest body: (required)
        :return: list[Order]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_order_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_order_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_order_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a conversion order  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_order_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OrderRequest body: (required)
        :return: list[Order]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/orders', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Order]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_original_recording(self, data, parent_folder_id, microphone, label, **kwargs):  # noqa: E501
        """Create an original recording  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_original_recording(data, parent_folder_id, microphone, label, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str data: (required)
        :param str parent_folder_id: (required)
        :param str microphone: (required)
        :param str label: (required)
        :return: Recording
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_original_recording_with_http_info(data, parent_folder_id, microphone, label, **kwargs)  # noqa: E501
        else:
            (data) = self.create_original_recording_with_http_info(data, parent_folder_id, microphone, label, **kwargs)  # noqa: E501
            return data

    def create_original_recording_with_http_info(self, data, parent_folder_id, microphone, label, **kwargs):  # noqa: E501
        """Create an original recording  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_original_recording_with_http_info(data, parent_folder_id, microphone, label, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str data: (required)
        :param str parent_folder_id: (required)
        :param str microphone: (required)
        :param str label: (required)
        :return: Recording
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data', 'parent_folder_id', 'microphone', 'label']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_original_recording" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `create_original_recording`")  # noqa: E501
        # verify the required parameter 'parent_folder_id' is set
        if ('parent_folder_id' not in params or
                params['parent_folder_id'] is None):
            raise ValueError("Missing the required parameter `parent_folder_id` when calling `create_original_recording`")  # noqa: E501
        # verify the required parameter 'microphone' is set
        if ('microphone' not in params or
                params['microphone'] is None):
            raise ValueError("Missing the required parameter `microphone` when calling `create_original_recording`")  # noqa: E501
        # verify the required parameter 'label' is set
        if ('label' not in params or
                params['label'] is None):
            raise ValueError("Missing the required parameter `label` when calling `create_original_recording`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'data' in params:
            local_var_files['data'] = params['data']  # noqa: E501
        if 'parent_folder_id' in params:
            form_params.append(('parent_folder_id', params['parent_folder_id']))  # noqa: E501
        if 'microphone' in params:
            form_params.append(('microphone', params['microphone']))  # noqa: E501
        if 'label' in params:
            form_params.append(('label', params['label']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/recordings', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Recording',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_project(self, body, **kwargs):  # noqa: E501
        """Create a new project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProjectRequest body: (required)
        :return: ProjectResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_project_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_project_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_project_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a new project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProjectRequest body: (required)
        :return: ProjectResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/projects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_tts_recording(self, body, **kwargs):  # noqa: E501
        """Create an original text-to-speech recording  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_tts_recording(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TTSRecordingRequest body: (required)
        :return: Recording
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_tts_recording_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_tts_recording_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_tts_recording_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create an original text-to-speech recording  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_tts_recording_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TTSRecordingRequest body: (required)
        :return: Recording
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_tts_recording" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_tts_recording`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/recordings/tts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Recording',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_api_key(self, **kwargs):  # noqa: E501
        """Delete the API key associated with your account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_api_key(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_api_key_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_api_key_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_api_key_with_http_info(self, **kwargs):  # noqa: E501
        """Delete the API key associated with your account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_api_key_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_api_key" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/api-key', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_calibration(self, calibration_id, **kwargs):  # noqa: E501
        """Delete a calibration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_calibration(calibration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str calibration_id: (required)
        :return: CalibrationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_calibration_with_http_info(calibration_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_calibration_with_http_info(calibration_id, **kwargs)  # noqa: E501
            return data

    def delete_calibration_with_http_info(self, calibration_id, **kwargs):  # noqa: E501
        """Delete a calibration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_calibration_with_http_info(calibration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str calibration_id: (required)
        :return: CalibrationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['calibration_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_calibration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'calibration_id' is set
        if ('calibration_id' not in params or
                params['calibration_id'] is None):
            raise ValueError("Missing the required parameter `calibration_id` when calling `delete_calibration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'calibration_id' in params:
            path_params['calibration_id'] = params['calibration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/calibration/{calibration_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CalibrationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_folder(self, folder_id, **kwargs):  # noqa: E501
        """Delete a folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_folder(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: (required)
        :return: list[InlineResponse2004]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_folder_with_http_info(folder_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_folder_with_http_info(folder_id, **kwargs)  # noqa: E501
            return data

    def delete_folder_with_http_info(self, folder_id, **kwargs):  # noqa: E501
        """Delete a folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_folder_with_http_info(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: (required)
        :return: list[InlineResponse2004]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params or
                params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `delete_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folder_id'] = params['folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/folders/{folder_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse2004]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_note(self, body, **kwargs):  # noqa: E501
        """Delete a note  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_note(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NoteDeleteRequest body: (required)
        :return: NoteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_note_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_note_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def delete_note_with_http_info(self, body, **kwargs):  # noqa: E501
        """Delete a note  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_note_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NoteDeleteRequest body: (required)
        :return: NoteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `delete_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/notes', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NoteResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_project(self, project_id, **kwargs):  # noqa: E501
        """Delete a project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_id: (required)
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_project_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_project_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def delete_project_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Delete a project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_id: (required)
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `delete_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/projects/{project_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2004',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_recording(self, recording_id, **kwargs):  # noqa: E501
        """Delete a recording  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_recording(recording_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str recording_id: The ID of the recording to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_recording_with_http_info(recording_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_recording_with_http_info(recording_id, **kwargs)  # noqa: E501
            return data

    def delete_recording_with_http_info(self, recording_id, **kwargs):  # noqa: E501
        """Delete a recording  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_recording_with_http_info(recording_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str recording_id: The ID of the recording to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['recording_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_recording" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'recording_id' is set
        if ('recording_id' not in params or
                params['recording_id'] is None):
            raise ValueError("Missing the required parameter `recording_id` when calling `delete_recording`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'recording_id' in params:
            path_params['recording_id'] = params['recording_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/recordings/{recording_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_calibration(self, calibration_id, **kwargs):  # noqa: E501
        """Set a calibration as the default enabled calibration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_calibration(calibration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str calibration_id: (required)
        :return: list[CalibrationResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_calibration_with_http_info(calibration_id, **kwargs)  # noqa: E501
        else:
            (data) = self.enable_calibration_with_http_info(calibration_id, **kwargs)  # noqa: E501
            return data

    def enable_calibration_with_http_info(self, calibration_id, **kwargs):  # noqa: E501
        """Set a calibration as the default enabled calibration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_calibration_with_http_info(calibration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str calibration_id: (required)
        :return: list[CalibrationResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['calibration_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_calibration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'calibration_id' is set
        if ('calibration_id' not in params or
                params['calibration_id'] is None):
            raise ValueError("Missing the required parameter `calibration_id` when calling `enable_calibration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'calibration_id' in params:
            path_params['calibration_id'] = params['calibration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/calibration/{calibration_id}/enable', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CalibrationResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def export_project(self, project_id, **kwargs):  # noqa: E501
        """Export a project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_project(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_id: (required)
        :param bool starred_only:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.export_project_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.export_project_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def export_project_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Export a project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_project_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_id: (required)
        :param bool starred_only:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'starred_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `export_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []
        if 'starred_only' in params:
            query_params.append(('starred_only', params['starred_only']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/zip'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/projects/{project_id}/export', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def favorite_voice(self, body, voice_id, **kwargs):  # noqa: E501
        """Mark a voice as a favorite  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.favorite_voice(body, voice_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FavoriteVoiceIdBody body: (required)
        :param str voice_id: (required)
        :return: Voice
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.favorite_voice_with_http_info(body, voice_id, **kwargs)  # noqa: E501
        else:
            (data) = self.favorite_voice_with_http_info(body, voice_id, **kwargs)  # noqa: E501
            return data

    def favorite_voice_with_http_info(self, body, voice_id, **kwargs):  # noqa: E501
        """Mark a voice as a favorite  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.favorite_voice_with_http_info(body, voice_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FavoriteVoiceIdBody body: (required)
        :param str voice_id: (required)
        :return: Voice
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'voice_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method favorite_voice" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `favorite_voice`")  # noqa: E501
        # verify the required parameter 'voice_id' is set
        if ('voice_id' not in params or
                params['voice_id'] is None):
            raise ValueError("Missing the required parameter `voice_id` when calling `favorite_voice`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'voice_id' in params:
            path_params['voice_id'] = params['voice_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/voices/favorite/{voice_id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Voice',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def generate_api_key(self, body, **kwargs):  # noqa: E501
        """Generate a new API key  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_api_key(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApiApikeyBody body: (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.generate_api_key_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.generate_api_key_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def generate_api_key_with_http_info(self, body, **kwargs):  # noqa: E501
        """Generate a new API key  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_api_key_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApiApikeyBody body: (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_api_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `generate_api_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/api-key', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_accent_samples(self, accent_id, **kwargs):  # noqa: E501
        """Get samples available for an accent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_accent_samples(accent_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str accent_id: (required)
        :return: AccentSamplesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_accent_samples_with_http_info(accent_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_accent_samples_with_http_info(accent_id, **kwargs)  # noqa: E501
            return data

    def get_accent_samples_with_http_info(self, accent_id, **kwargs):  # noqa: E501
        """Get samples available for an accent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_accent_samples_with_http_info(accent_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str accent_id: (required)
        :return: AccentSamplesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['accent_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_accent_samples" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'accent_id' is set
        if ('accent_id' not in params or
                params['accent_id'] is None):
            raise ValueError("Missing the required parameter `accent_id` when calling `get_accent_samples`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'accent_id' in params:
            query_params.append(('accent_id', params['accent_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/accents/samples', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccentSamplesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_statistics(self, **kwargs):  # noqa: E501
        """Get the statistics for your account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_statistics(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AccountStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_statistics_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_account_statistics_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_account_statistics_with_http_info(self, **kwargs):  # noqa: E501
        """Get the statistics for your account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_statistics_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AccountStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_statistics" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccountStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_calibration(self, calibration_id, **kwargs):  # noqa: E501
        """Get a calibration by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_calibration(calibration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str calibration_id: (required)
        :return: CalibrationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_calibration_with_http_info(calibration_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_calibration_with_http_info(calibration_id, **kwargs)  # noqa: E501
            return data

    def get_calibration_with_http_info(self, calibration_id, **kwargs):  # noqa: E501
        """Get a calibration by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_calibration_with_http_info(calibration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str calibration_id: (required)
        :return: CalibrationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['calibration_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_calibration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'calibration_id' is set
        if ('calibration_id' not in params or
                params['calibration_id'] is None):
            raise ValueError("Missing the required parameter `calibration_id` when calling `get_calibration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'calibration_id' in params:
            path_params['calibration_id'] = params['calibration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/calibration/{calibration_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CalibrationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_credits(self, **kwargs):  # noqa: E501
        """Get the credits available to your account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credits(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_credits_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_credits_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_credits_with_http_info(self, **kwargs):  # noqa: E501
        """Get the credits available to your account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credits_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credits" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/credits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_folder_by_id(self, folder_id, **kwargs):  # noqa: E501
        """Get a folder by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_by_id(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_folder_by_id_with_http_info(folder_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_folder_by_id_with_http_info(folder_id, **kwargs)  # noqa: E501
            return data

    def get_folder_by_id_with_http_info(self, folder_id, **kwargs):  # noqa: E501
        """Get a folder by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_by_id_with_http_info(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_folder_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params or
                params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `get_folder_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folder_id'] = params['folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/folders/{folder_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Folder',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_folders_statistics(self, body, **kwargs):  # noqa: E501
        """Get statistics for a list of folders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folders_statistics(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FoldersStatisticsRequest body: (required)
        :return: FoldersStatisticsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_folders_statistics_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.get_folders_statistics_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def get_folders_statistics_with_http_info(self, body, **kwargs):  # noqa: E501
        """Get statistics for a list of folders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folders_statistics_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FoldersStatisticsRequest body: (required)
        :return: FoldersStatisticsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_folders_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_folders_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/stats/folders', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FoldersStatisticsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_project_by_url(self, project_url, **kwargs):  # noqa: E501
        """Get a project by its URL  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_by_url(project_url, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_url: (required)
        :return: ProjectResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_project_by_url_with_http_info(project_url, **kwargs)  # noqa: E501
        else:
            (data) = self.get_project_by_url_with_http_info(project_url, **kwargs)  # noqa: E501
            return data

    def get_project_by_url_with_http_info(self, project_url, **kwargs):  # noqa: E501
        """Get a project by its URL  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_by_url_with_http_info(project_url, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_url: (required)
        :return: ProjectResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_url']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_by_url" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_url' is set
        if ('project_url' not in params or
                params['project_url'] is None):
            raise ValueError("Missing the required parameter `project_url` when calling `get_project_by_url`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_url' in params:
            query_params.append(('project_url', params['project_url']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/projects/by-url', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_projects_statistics(self, **kwargs):  # noqa: E501
        """Get statistics for a list of projects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_projects_statistics(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_ids: Comma-separated list of project IDs to fetch statistics for.
        :return: list[ProjectsStatisticsResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_projects_statistics_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_projects_statistics_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_projects_statistics_with_http_info(self, **kwargs):  # noqa: E501
        """Get statistics for a list of projects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_projects_statistics_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_ids: Comma-separated list of project IDs to fetch statistics for.
        :return: list[ProjectsStatisticsResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_projects_statistics" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_ids' in params:
            query_params.append(('project_ids', params['project_ids']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/stats/projects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProjectsStatisticsResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recording_by_id(self, recording_id, **kwargs):  # noqa: E501
        """Get a recording by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recording_by_id(recording_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str recording_id: The ID of the recording to fetch (required)
        :return: Recording
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recording_by_id_with_http_info(recording_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_recording_by_id_with_http_info(recording_id, **kwargs)  # noqa: E501
            return data

    def get_recording_by_id_with_http_info(self, recording_id, **kwargs):  # noqa: E501
        """Get a recording by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recording_by_id_with_http_info(recording_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str recording_id: The ID of the recording to fetch (required)
        :return: Recording
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['recording_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recording_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'recording_id' is set
        if ('recording_id' not in params or
                params['recording_id'] is None):
            raise ValueError("Missing the required parameter `recording_id` when calling `get_recording_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'recording_id' in params:
            path_params['recording_id'] = params['recording_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/recordings/{recording_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Recording',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_calibrations(self, **kwargs):  # noqa: E501
        """Get a list of calibrations associated with your account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_calibrations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[CalibrationResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_calibrations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_calibrations_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_calibrations_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of calibrations associated with your account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_calibrations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[CalibrationResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_calibrations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/calibration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CalibrationResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_conversions(self, original_id, **kwargs):  # noqa: E501
        """Get a list of the conversions for an original recording  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_conversions(original_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str original_id: (required)
        :param int limit:
        :param int offset:
        :param str direction:
        :return: RecordingListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_conversions_with_http_info(original_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_conversions_with_http_info(original_id, **kwargs)  # noqa: E501
            return data

    def list_conversions_with_http_info(self, original_id, **kwargs):  # noqa: E501
        """Get a list of the conversions for an original recording  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_conversions_with_http_info(original_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str original_id: (required)
        :param int limit:
        :param int offset:
        :param str direction:
        :return: RecordingListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['original_id', 'limit', 'offset', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_conversions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'original_id' is set
        if ('original_id' not in params or
                params['original_id'] is None):
            raise ValueError("Missing the required parameter `original_id` when calling `list_conversions`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'original_id' in params:
            query_params.append(('original_id', params['original_id']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/recordings/conversions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RecordingListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_folders(self, project_id, **kwargs):  # noqa: E501
        """Get a list of the folders in a project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_folders(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_id: (required)
        :param int limit:
        :param int offset:
        :param str direction:
        :return: FolderListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_folders_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_folders_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def list_folders_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get a list of the folders in a project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_folders_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_id: (required)
        :param int limit:
        :param int offset:
        :param str direction:
        :return: FolderListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'limit', 'offset', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_folders" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `list_folders`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in params:
            query_params.append(('project_id', params['project_id']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/folders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FolderListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_original_recordings(self, **kwargs):  # noqa: E501
        """Get a list of the original recordings in a folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_original_recordings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RecordingListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_original_recordings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_original_recordings_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_original_recordings_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of the original recordings in a folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_original_recordings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RecordingListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_original_recordings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/recordings/originals', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RecordingListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_projects(self, **kwargs):  # noqa: E501
        """Get a list of your projects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_projects(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: The maximum number of projects to list.
        :param int offset: The number of projects to offset the list by.
        :param str sort: Sort by name, created_at or last_recording_at.
        :param str direction: Order projects by asc or desc.
        :param str owner: List projects for a specific owner ID.
        :return: ProjectListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_projects_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_projects_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_projects_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of your projects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_projects_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: The maximum number of projects to list.
        :param int offset: The number of projects to offset the list by.
        :param str sort: Sort by name, created_at or last_recording_at.
        :param str direction: Order projects by asc or desc.
        :param str owner: List projects for a specific owner ID.
        :return: ProjectListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'offset', 'sort', 'direction', 'owner']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_projects" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501
        if 'owner' in params:
            query_params.append(('owner', params['owner']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/projects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_recordings(self, **kwargs):  # noqa: E501
        """Get a list of recordings for a specified folder or project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_recordings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_id:
        :param str folder_id:
        :param int limit:
        :param int offset:
        :param str direction:
        :return: RecordingListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_recordings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_recordings_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_recordings_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of recordings for a specified folder or project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_recordings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_id:
        :param str folder_id:
        :param int limit:
        :param int offset:
        :param str direction:
        :return: RecordingListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'folder_id', 'limit', 'offset', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_recordings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in params:
            query_params.append(('project_id', params['project_id']))  # noqa: E501
        if 'folder_id' in params:
            query_params.append(('folder_id', params['folder_id']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/recordings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RecordingListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_tts_voices(self, **kwargs):  # noqa: E501
        """Get a list of the available TTS voices  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_tts_voices(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[TTSVoice]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_tts_voices_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_tts_voices_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_tts_voices_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of the available TTS voices  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_tts_voices_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[TTSVoice]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_tts_voices" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/tts-voices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TTSVoice]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_voices(self, **kwargs):  # noqa: E501
        """Get a list of the voices available  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_voices(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: Limits the number of voices returned in the response. Defaults to 25.
        :param int offset: Offsets the list of voices to paginate through results. Defaults to 0.
        :param str sort: Sorts the voices by a specified attribute (e.g., name, pitch, rating, or created_at).
        :param str direction: Specifies the direction of sorting. Can be 'asc' for ascending or 'desc' for descending.
        :param str visibility: Filters voices by their visibility status (e.g., public, paid, private, or kids).
        :param str species: Filters voices by species category (e.g., human, animal, or other).
        :param str gender: Filters voices by gender (e.g., male or female).
        :param str age_group: Filters voices by age group (e.g., child, young, adult, or senior).
        :param str pitch_group: Filters voices by pitch group (e.g., low, mid, or high).
        :param str nationality: Filters voices by nationality.
        :return: VoicesListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_voices_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_voices_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_voices_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of the voices available  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_voices_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: Limits the number of voices returned in the response. Defaults to 25.
        :param int offset: Offsets the list of voices to paginate through results. Defaults to 0.
        :param str sort: Sorts the voices by a specified attribute (e.g., name, pitch, rating, or created_at).
        :param str direction: Specifies the direction of sorting. Can be 'asc' for ascending or 'desc' for descending.
        :param str visibility: Filters voices by their visibility status (e.g., public, paid, private, or kids).
        :param str species: Filters voices by species category (e.g., human, animal, or other).
        :param str gender: Filters voices by gender (e.g., male or female).
        :param str age_group: Filters voices by age group (e.g., child, young, adult, or senior).
        :param str pitch_group: Filters voices by pitch group (e.g., low, mid, or high).
        :param str nationality: Filters voices by nationality.
        :return: VoicesListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'offset', 'sort', 'direction', 'visibility', 'species', 'gender', 'age_group', 'pitch_group', 'nationality']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_voices" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501
        if 'visibility' in params:
            query_params.append(('visibility', params['visibility']))  # noqa: E501
        if 'species' in params:
            query_params.append(('species', params['species']))  # noqa: E501
        if 'gender' in params:
            query_params.append(('gender', params['gender']))  # noqa: E501
        if 'age_group' in params:
            query_params.append(('age_group', params['age_group']))  # noqa: E501
        if 'pitch_group' in params:
            query_params.append(('pitch_group', params['pitch_group']))  # noqa: E501
        if 'nationality' in params:
            query_params.append(('nationality', params['nationality']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/voices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VoicesListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def login(self, body, **kwargs):  # noqa: E501
        """Log in to an account and start a new session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.login(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApiLoginBody body: (required)
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.login_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.login_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def login_with_http_info(self, body, **kwargs):  # noqa: E501
        """Log in to an account and start a new session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.login_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApiLoginBody body: (required)
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method login" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `login`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/login', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def logout(self, **kwargs):  # noqa: E501
        """End your session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logout(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.logout_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.logout_with_http_info(**kwargs)  # noqa: E501
            return data

    def logout_with_http_info(self, **kwargs):  # noqa: E501
        """End your session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logout_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logout" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/logout', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rename_folder(self, body, folder_id, **kwargs):  # noqa: E501
        """Rename a folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rename_folder(body, folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FoldersFolderIdBody body: (required)
        :param str folder_id: (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.rename_folder_with_http_info(body, folder_id, **kwargs)  # noqa: E501
        else:
            (data) = self.rename_folder_with_http_info(body, folder_id, **kwargs)  # noqa: E501
            return data

    def rename_folder_with_http_info(self, body, folder_id, **kwargs):  # noqa: E501
        """Rename a folder  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rename_folder_with_http_info(body, folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FoldersFolderIdBody body: (required)
        :param str folder_id: (required)
        :return: Folder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'folder_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rename_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `rename_folder`")  # noqa: E501
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params or
                params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `rename_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folder_id'] = params['folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/folders/{folder_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Folder',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retry_order_v2(self, recording_id, **kwargs):  # noqa: E501
        """Retry a conversion order for a specific original  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retry_order_v2(recording_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str recording_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retry_order_v2_with_http_info(recording_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retry_order_v2_with_http_info(recording_id, **kwargs)  # noqa: E501
            return data

    def retry_order_v2_with_http_info(self, recording_id, **kwargs):  # noqa: E501
        """Retry a conversion order for a specific original  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retry_order_v2_with_http_info(recording_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str recording_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['recording_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retry_order_v2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'recording_id' is set
        if ('recording_id' not in params or
                params['recording_id'] is None):
            raise ValueError("Missing the required parameter `recording_id` when calling `retry_order_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'recording_id' in params:
            path_params['recording_id'] = params['recording_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/orders/retry/{recording_id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_voices(self, name, **kwargs):  # noqa: E501
        """Search for a voice by its name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_voices(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: (required)
        :param int limit:
        :return: list[Voice]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_voices_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.search_voices_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def search_voices_with_http_info(self, name, **kwargs):  # noqa: E501
        """Search for a voice by its name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_voices_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: (required)
        :param int limit:
        :return: list[Voice]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_voices" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `search_voices`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/voices/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Voice]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_voice_settings(self, body, **kwargs):  # noqa: E501
        """Set the settings for a voice  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_voice_settings(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VoiceSettingsRequest body: (required)
        :return: Voice
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_voice_settings_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.set_voice_settings_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def set_voice_settings_with_http_info(self, body, **kwargs):  # noqa: E501
        """Set the settings for a voice  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_voice_settings_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VoiceSettingsRequest body: (required)
        :return: Voice
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_voice_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_voice_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/voices/settings', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Voice',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_note(self, body, **kwargs):  # noqa: E501
        """Update a note  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_note(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NoteRequest body: (required)
        :return: NoteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_note_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_note_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def update_note_with_http_info(self, body, **kwargs):  # noqa: E501
        """Update a note  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_note_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NoteRequest body: (required)
        :return: NoteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/notes', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NoteResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_project(self, body, project_id, **kwargs):  # noqa: E501
        """Change the name of a project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_project(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProjectsProjectIdBody body: (required)
        :param str project_id: (required)
        :return: ProjectResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_project_with_http_info(body, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_project_with_http_info(body, project_id, **kwargs)  # noqa: E501
            return data

    def update_project_with_http_info(self, body, project_id, **kwargs):  # noqa: E501
        """Change the name of a project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_project_with_http_info(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProjectsProjectIdBody body: (required)
        :param str project_id: (required)
        :return: ProjectResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_project`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/projects/{project_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_recording(self, body, recording_id, **kwargs):  # noqa: E501
        """Update a recording  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_recording(body, recording_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RecordingsRecordingIdBody body: (required)
        :param str recording_id: The ID of the recording to update (required)
        :return: Recording
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_recording_with_http_info(body, recording_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_recording_with_http_info(body, recording_id, **kwargs)  # noqa: E501
            return data

    def update_recording_with_http_info(self, body, recording_id, **kwargs):  # noqa: E501
        """Update a recording  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_recording_with_http_info(body, recording_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RecordingsRecordingIdBody body: (required)
        :param str recording_id: The ID of the recording to update (required)
        :return: Recording
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'recording_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_recording" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_recording`")  # noqa: E501
        # verify the required parameter 'recording_id' is set
        if ('recording_id' not in params or
                params['recording_id'] is None):
            raise ValueError("Missing the required parameter `recording_id` when calling `update_recording`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'recording_id' in params:
            path_params['recording_id'] = params['recording_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/recordings/{recording_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Recording',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
